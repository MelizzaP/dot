---
allowed-tools:
  - Read
  - Glob
  - Grep
  - Write
  - Edit
  - Bash
  - Task
  - TodoWrite
  - AskUserQuestion
  - mcp__sentient-agi-reasoning__code-reasoning
---

# Implement Task from Spec

Implements a single atomic task from an implementation specification document generated by `/write-spec`.

## Input

$ARGUMENTS - Either:
- A task number (e.g., `3`) - will look for the most recent spec or ask which spec to use
- A spec path and task number (e.g., `specs/feature-name-spec.md 3`)
- A spec path and task name (e.g., `specs/feature-name-spec.md "Create migration"`)

## Instructions

### Phase 1: Load and Parse Spec

**Locate the spec document:**
- If full path provided, read it directly
- If only task number provided:
  - List files in `specs/` directory
  - If one spec exists, use it
  - If multiple specs exist, ask user to select one
- If spec not found, show available specs and exit

**Extract the target task:**
- Parse the spec document to find the specified task (by number or name)
- Extract all task details:
  - Summary
  - Dependencies
  - Files to create/modify
  - Detailed specification
  - Edge cases
  - Acceptance criteria
  - Testing requirements
  - Notes/Warnings

**Validate dependencies:**
- Check if dependent tasks are mentioned as completed in the spec or codebase
- If dependencies appear incomplete, warn the user and ask whether to proceed
- List what the dependent tasks were supposed to deliver

### Phase 2: Pre-Implementation Analysis

**Create a todo list for this task:**
Use TodoWrite to create a checklist based on:
1. Each file that needs to be created or modified
2. Each acceptance criterion
3. Writing tests
4. Running tests

**Understand the context:**
- Read all files mentioned in "Files to create/modify"
- Read any files mentioned in the detailed specification
- If the spec references existing patterns, read those examples
- Understand the existing code structure before making changes

**Identify risks:**
- Note any warnings from the spec
- Consider edge cases listed
- Flag anything unclear for clarification

### Phase 3: Implementation

**Follow the spec precisely:**
- Implement exactly what the spec describes
- Use the patterns and conventions referenced in the spec
- Create files in the locations specified
- Match the data structures and API contracts defined

**Implementation order:**
1. Data/Schema changes first (migrations, types, models)
2. Core business logic
3. API/Interface layer
4. Integration points
5. Tests

**Best practices:**
- Make small, incremental changes
- Keep changes focused on this single task
- Don't refactor unrelated code
- Don't add features not in the spec
- Follow existing codebase conventions

**As you complete each item:**
- Mark the corresponding todo as complete
- Note any deviations from spec (and why)

### Phase 4: Testing

**Write required tests:**
- Implement all tests specified in "Testing requirements"
- Cover edge cases listed in the spec
- Follow existing test patterns in the codebase

**Run tests:**
```bash
# Run the full test suite or relevant subset
mix test                           # Elixir
pytest                             # Python
npm test                           # JavaScript/TypeScript
```

**Verify all tests pass:**
- If tests fail, fix the implementation
- Do not mark the task complete with failing tests

### Phase 5: Verification

**Check each acceptance criterion:**
Go through the acceptance criteria one by one and verify:
- [ ] Each criterion is met
- [ ] Tests prove the criterion is met
- [ ] Edge cases are handled

**Code quality check:**
- Review your changes for obvious issues
- Ensure no debug code or TODOs left behind
- Verify no secrets or sensitive data exposed
- Check that error handling is appropriate

**Run static analysis if available:**
```bash
mix credo                          # Elixir
mix dialyzer                       # Elixir type checking
pylint / mypy                      # Python
eslint / tsc                       # TypeScript
```

### Phase 6: Summary Report

**Generate implementation summary:**

```markdown
## Implementation Complete: Task [N] - [Name]

### Changes Made
- `path/to/file.ex` - [what was done]
- `path/to/other.ex` - [what was done]

### Acceptance Criteria Status
- [x] [Criterion 1] - Verified by [test/manual check]
- [x] [Criterion 2] - Verified by [test/manual check]

### Tests Added
- `test/path/to/test.exs` - [what's tested]

### Test Results
[Pass/Fail summary]

### Deviations from Spec
[None, or list any necessary deviations and why]

### Notes for Reviewer
[Any context helpful for code review]

### Ready for Next Task?
Unblocked tasks: [List task numbers that can now be started]
```

## Error Handling

**If spec is ambiguous:**
- Use AskUserQuestion to clarify
- Document the clarification for future reference

**If implementation is blocked:**
- Clearly explain what's blocking
- Suggest how to unblock (missing dependency, unclear requirement, etc.)
- Don't leave partial implementations without clear status

**If tests fail:**
- Show the failure output
- Attempt to fix
- If unable to fix, report what was tried and ask for help

## Important Constraints

- **Stay focused** - Only implement what's in this task's spec
- **Follow the spec** - The spec was carefully designed; trust it
- **Test everything** - Every acceptance criterion needs verification
- **Document deviations** - If you must deviate from spec, explain why
- **Don't break existing functionality** - Run the full test suite
- **Keep it atomic** - This should be a single, mergeable PR

## Example Usage

```
/implement 3
```

This would:
1. Find the spec file (or ask which one)
2. Extract Task 3's specification
3. Create a todo list for the task
4. Implement the task following the spec
5. Write and run tests
6. Verify acceptance criteria
7. Report completion status

```
/implement specs/batch-analysis-spec.md 5
```

This would implement Task 5 from the specified spec file.

```
/implement specs/auth-spec.md "Add JWT validation"
```

This would find and implement the task named "Add JWT validation" from the auth spec.
